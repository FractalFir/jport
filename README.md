# jtcpp - experimental JVM bytecode to C++ converter
## Why was `jtcpp` created?
One of my favourite parts of programming is solving very hard problems. Engineering a solution to a problem, which seems impossible at first, helps to become confident in ones own skills, and to broader horizons. Seeing popularity of JVM-oriented languages, I wanted to learn a little bit more about the inner workings of the virtual machine powering some of the most popular languages out there. So my joinery for a problem that *definetly* needed solving began.

Large chunk of the codebase comes from my previous attempt at creating a Java Runtime written in `Rust`. It did work, and could run simple programs, such as the Sieve of  Eratosthenes's, but was way too slow for my liking, which killed my motivation, so I decided to try and find something else to do.

When looking deeper into both Java, and JVM, one thing struck me as odd. May people seem to believe it to be inherently slow, and many articles try to convince you it really is not. Often, when discussing performance of Java compared to other programming languages, there are many reasons stated, explaing why it is "slower" than alternatives. Of the reasons cited, one that crops up often is use of Bytecode and JVM instead of compiling to a native executable. But is this really relevant, especially with clever optimisations and JIT compiling preformed by the JVM? With this question `jtcpp`(at first `jtc`, but converting Java to `C` turned out to be not worth the hastle) was born. This project aims to asses how much compiling java to native code impacts the performance. `jtcpp` Takes in each java class separately, translating Java classes into C++ code one by one.
## WIP
This project was created as a learning challenge for me. It supports a subset of Java ops, but not everything works. Calling the implementation of java standard library bare-bones would be an understatement, it consists of only the things strictly necessary to run simple tests. I might add more features in the future, but it all depends on if I will be able to overcome some more serious roadblocks.
### InvokeDynamic - codegen during runtime is shockingly common in Java.
The single, biggest issue which makes some programs impossible to properly translate to C++ is code generation during runtime. At first, it may seem like something that would be pretty rare and used in very specific places(eg. Reflection API) but it is not. `InvokeDynamic` is an opcode which calls a method generated by the associated bootstrap method. You can find it all over the place: It is even emitted where it is not strictly necessary, because generating bytecode during runtime often leads to smaller `.jar` sizes and significantly faster startup times. This is a big issue, because `jtcpp` translates JVM bytecode to C++ before compiling, and can't emit any more code at runtime.
### UTF16
Currently, `jtcpp` uses UTF16 in C++ code translated bytecode, and then converts it to UTF-8 to do any IO, including printing to console. This might have a negative impact on performance of generated code.
## Some comparisons
*NOTE* used benchmarks can't use features not supported by `jtcpp` which could(but probably did not) negatively impact performance of code, making JVM perform worse than it should have.
| Benchmark | `jtcpp` generated C++ code | `openjdk version "17.0.7" 2023-04-18` |
| NBody simulation, n = 30, 1 000 000 iterations | 
